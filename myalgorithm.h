#pragma once
// P.S. Комментарии пока что будут на русском -_- //
#ifndef ON
#define ON

#include <iostream>
#include <cmath>
#include <vector>
#include <string>
#include <sstream>
#include <thread>
#include "SimpleTimer.h"

typedef SimpleTimer timer;
typedef std::string string;
const string tab = "    ";

#define PI 3.141592653589793
#define RADIAN 180/PI
#define DEGREE PI/180

namespace thread = std::this_thread;
namespace chrono = std::chrono;



///  return begin elements  ///
template <typename T, size_t N>
const T* begin(const T(&str)[N]) { return str; }

///  return end elements  ///
template <typename T, size_t N>
const T* end(const T(&str)[N]) { return str + N; }

/// return size array ///
template <typename T, size_t N>
const T size(const T(&str)[N]) { return N; }


/// ranks ///
template <typename T>
uint16_t ranks(const T& val)	                                  // Функция для определиная кол-во разрядов в числе
{
	uint32_t res = 0;
	T temp = val;
	do {
		temp /= 10;
		res++;
	} while (temp > 0);

	return res;
}


/// convert str in number or nymber vice versa  ///
template<typename T>
T convert(const std::string& s)                                   // Конвертация строки в число (Код не мой)
{
	std::istringstream iss(s, std::istringstream::in);
	T res{};
	iss >> res;
	return res;
}

template<typename T>
std::string convert(T val)                                        // Конвертация числа в строку (Код не мой)
{
	std::ostringstream oss;
	oss << val;
	return oss.str();
}


/// factorial of a number ///
uint64_t factorial(uint16_t N)                                    // Функция для вычесления факториала числа
{ return N > 1 ? N * factorial(N - 1) : 1; }    


/// degree of a number ///
uint64_t degree(uint64_t x, uint64_t y)                           // Функция для вычесления степени числа
{ return y ? x * degree(x, y - 1) : 1; }    


/// swap number ///
template<typename T>
void swap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}


//   string     //
///  operators  ///
std::string operator*(const std::string& str,                     // Перегруженный бинарный оператор *, 
	const uint32_t& num)                                          // позволяет продублировать строку указанное кол - во раз
{ return num ? str + operator*(str, num - 1) : ""; }                 

std::string operator*(const uint32_t& num,                        // Перегруженный бинарный оператор *, 
	const std::string& str)										  // позволяет продублировать строку указанное кол-во раз
{ return operator*(str, num); }    

std::string& operator/(std::string& str,                          // Перегруженный бинарный оператор /, позволяет удалить все подстроки(str2) из строки (str)
	const std::string& str2) {
	return str.find(str2) != str.npos ? 
		operator/(str.erase(str.find(str2), str2.length()), str2) 
		: str; }    

std::string& operator-(std::string& str,                          // Перегруженный бинарный оператор -, удаляет подстроку(str2) из строки (str)
	const std::string& str2) {
	return str.find(str2) != str.npos ?
		str.erase(str.find(str2), str2.length()) 
		: str; }	 


bool operator==(const std::string& str, const std::string& str2)  // Перегруженный бинарный оператор ==, позволяет сравнить две строки между собой
{ return str.size() == str2.size() && str.find(str2) != str.npos; }    

bool operator!=(const std::string& str, const std::string& str2)  // Перегруженный бинарный оператор !=, позволяет проверить на неравенство две строки между собой
{ return str.size() != str2.size() || str.find(str2) == str.npos; }  

// function //
size_t strlen_t(const char* str, size_t len = 0)                  // Функция позволяет узнать размер строки (в учет размера строки не входит терминирующий нуль)
{ return str[len] ? strlen_t(str, len + 1) : len; }    


/// math ///
// Функции для работы с базовой математикой //
// Следующий функции позволяют работать с арифметической прогрессии //
std::vector<double_t> aritho(const double_t& a1,                  // Функция позволяет создать вектор арифметической прогрессии
	const double_t& d, 
	const uint32_t& size, 
	std::vector<double_t> v) {    
	v.at(0) = a1; v.resize(size);
	for (auto i = v.begin() + 1; i < v.end(); i++)
		*i = *(i - 1) + d;
	return v;
}

inline double_t aritho_d(const std::vector<double_t>& v)          // Позволяет узнать разность между элементами арифметической прогрессии
{ return v.at(1) - v.at(0); }    

inline double_t aritho_sum(std::vector<double_t>& v)              // Позволяет узнать сумму  арифметической прогрессии
{ return (v.at(0) + v.at(v.size() - 1)) / 2 * v.size(); }    

inline double_t aritho_search(const std::vector<double_t>& v,     // Позволяет найти элемент в существующей  арифметической прогрессии
	const uint32_t& an) { 
    return v.size() >= an ? v.at(an - 1) 
		: v.at(0) + aritho_d(v) * (an - 1); }    

size_t aritho_search(const double_t& el,                          // Позволяет найти каким по счету идет элемент в существующей
	const std::vector<double_t>& v) {                             // и не существующей  арифметической прогрессии
	if (std::find(v.begin(), v.end(), el) != v.end())
		return std::find(v.begin(), v.end(), el) - v.begin() + 1;

	size_t i = v.size() + 1;
	for (double_t d = aritho_d(v), g = v.at(i - 2) + d; 
		g <= el; 
		i++, g += d)
		if (g == el)
			return i;
	return NULL;
}

bool is_aritho(const std::vector<double_t>& v) {                  // Проверяет, является ли переданная арифметическая прогрессия арифметической прогрессией
	for (auto& el : v)
		if (el + aritho_d(v) != *(&el + 1) 
			&& el != v.at(v.size() - 1))
			return false;
	return true;
}



void timer_with_chrono()                                          // Таймер (фиговый-_*)
{
	char sec = 0, min = 0, hour = 0, day = 0;
	while (day < 1)
	{
		timer a;
		std::cout << "Passed time: "
			<< "sec: " << sec << string(" ") * (5 - ranks(sec))
			<< "min: " << min << string(" ") * (5 - ranks(min)) 
			<< "hour: " << hour << '\r';
		thread::sleep_for(chrono::milliseconds(999));

		if (sec == 60) {
			++min;
			if (min == 60) {
				++hour;
				if (hour == 24) {
					++day;
					std::cout << "Timer stoped!\nBye!\n";
				}
				min = 0;
			}
			sec = 0;
		}
		++sec;
	}
}

std::string decimal_to_binary(const uint64_t& val)                // Перевод числа из десятичной в двоичную систему счисления
{
	auto temp = val;
	std::string res;

	do {
		res += std::to_string(temp % 2);
		temp /= 2;
	} while (temp > 0);

	std::reverse(res.begin(), res.end());

	return res;
}

const uint64_t binary_to_decimal(const std::string& str)          // Перевод числа из двоичной системы счисления в десятичную
{
	if (str.size() > 64)
		return 0;
	uint64_t res = 0;
	for (size_t i = 0; i < str.size(); i++)
		res = res * 2 + str.at(i) - '0';
	return res;
}

// . . . TODO? . . .   //
//       SORT         //
/* template <typename T>
void mySort(const T arr[], const T * end)
{
	std::sort(arr, end, [](int a, int b)
	{
		return a > b;
	});
	const size_t size = (end - arr) / sizeof(T);
	T temp[size];
	for (int i = 0, g = 10 - 1, c = 0; i < (end - arr) / sizeof(T); i++)
		if (i % 2 == 0) {
			temp[c] = arr[i];
			c++;
		}
		else {
			temp[g] = arr[i];
			g--;
		}
	for (auto i = 0; i < (end - arr) / sizeof(T); i++)
		arr[i] = temp[i];
}
Original version:
int arr[10], temp[10], i = 0, g = 0, c = 0;
	for (auto &el : arr)
		el = rand() % 10 + 1;
	for (auto &el : arr)
		cout << el << endl;
	/*for (i = 0, g = 10 - 1; i < 10; i++)
		if (i % 2 == 0) {
			temp[c] = arr[i];
			c++;
		}
		else {
			temp[g] = arr[i];
			g--;
		}
	cout << endl;
	for (const auto &el : temp)
		cout << el << endl;
*/

///  matrix  ///
/// class Matrix ///
//  класс Матрица  //
//     TODO       //
template<class T>
class Matrix {                                                    //  class Matrix  //                                                              
	T** matrix;                                                   // Сама матрица
	uint32_t m, n;                                                // Строки и колонны 
public:
	Matrix(const uint32_t& m = 1,                                 // Конструктор не пол умолчанию класса Matrix. 
		const uint32_t& n = 1,                                    // Принимает кол-во строк, колонн, и то, чем заполнить матрицу
		const T& aggr = {}) : m(m), n(n)                          
	{
		matrix = new T*[m];
		for (uint32_t i = 0; i < m; i++) {
			matrix[i] = new T[n];
			for (uint32_t g = 0; g < n; g++)
				matrix[i][g] = aggr;
		}
	}

	~Matrix()                                                     // Деструктор класса Matrix
	{
		for (uint32_t i = 0; i < m; i++)
			delete[] matrix[i];
		delete[]matrix;
	}

	auto operator[](const uint32_t& m) const { return matrix[m]; }// перегруженный оператор обращение к эелементу массива по индексу

	T getM() { return m; }                                        // Геттер для m
	T getN() { return n; }                                        // Геттер для m
	T getSize() { return m * n; }                                 // Геттер для размера всего массива
	void getMat() const {										  // Геттер для выведения на экран всей матрицы
		for (uint32_t i = 0; i < m; i++) {
			for (uint32_t g = 0; g < n; g++)
				std::cout << matrix[i][g] << tab;
			std::cout << '\n';
		}
		std::cout.flush();
	}

	void arrgs(const T& top_half,                                 // Метод для заполнения матрицы указанными значениями для:
		const T& bottom_half,                                     // верхней половины, нижней половины, диагонали
		const T& diagonal) {    
		for (uint32_t i = 0; i < m; ++i)
			for (uint32_t g = 0; g < n; ++g)
				(*this)[i][g] = i < g ? top_half 
				: i > g ? bottom_half : diagonal;
	}

	const std::string search(T& el) const {                       // Метод для поиска элемента в матрице
		for (uint32_t i = 0; i < m; i++)
			for (uint32_t g = 0; g < n; g++)
				if ((*this)[i][g] == el)           
					return (std::to_string(i) += ' ')
					+= std::to_string(g);
		return "-1";
	}

	const std::string half(T& el) const {                         // Метод, для определения в какой половине находится элемент
		if (search(el) == "-1")
			return "Not found . . .\n";

		std::string i = search(el), g = i;
		i.erase(i.find(" ")); g.erase(0, g.find(" ") + 1);

		if (convert<int>(i) < convert<int>(g))
			return "top half\n";
		else if (convert<int>(i) > convert<int>(g))
			return "bottom half\n";
		return "Diagonal\n";
	}

	friend bool operator==(const Matrix<T>& m1,                   // Перегруженный оператор-друг для сравнения двух матриц
		const Matrix<T>& m2) {    
		if (m1.sizes() != m2.sizes())
			return false;
		for (uint32_t i = 0; i < m1.getM(); i++)
			for (uint32_t g = 0; g < m1.getN(); g++)
				if (m1[i][g] != m2[i][g])
					return false;
		return true;
	}

	friend std::ostream& operator<<(std::ostream& os,             // Перегруженный оператор-друг для вывода всех элементов матрицы
		const Matrix<T>& matrix) {   
		for (uint32_t i = 0; i < matrix.m; i++) {
			for (uint32_t g = 0; g < matrix.n; g++)
				std::cout << matrix[i][g] << tab;
			std::cout << '\n';
		}
		std::cout.flush();
		return os;
	}
	friend std::istream& operator>>(std::istream& os,             // Перегруженный оператор-друг для вывода всех элементов матрицы
		const Matrix<T>& matrix) {    
		for (uint32_t i = 0; i < matrix.m; i++) {
			for (uint32_t g = 0; g < matrix.n; g++) {
				std::cout << "Enter element:\n" 
					<< i << " -  Vertically\n" 
					<< g << " - Horizontally\n";
				std::cin >> matrix[i][g];
			}
			std::cout << '\n';
		}
		std::cout.flush();
		return os;
	}
	//  class Matrix end  //
};


size_t degree_two(const size_t& num, size_t res = 0)   
{ return num ? degree_two(num / 2, res + 1) : res; }              // Функция для вычесления, в какой степени двойка, будет больше чем переданный аргумент


template<class T>
class VecEno                                                      // класс VecEno
{
	size_t       size, _capacity;                                 // размер и капасити вектора
	const size_t MAX_SIZE = 65536 / sizeof(T);                    // максимальный размер для вектора (максимально можно создать объект размер которого будет 65536 байт)
	T*           array;                                           // сам массив
public:
	class iterator                                                // класс iterator
	{ 
		T* el;                                                    // элемент на который указывает итератор
	public: 
		iterator(T* elm) { el = elm; }                            // конструктор инициализацией уже указателем из вне // не безопасно
		iterator(iterator* elm) { el = elm->el; }                 // конструктор копирования
		T& operator*() const { return *el; }                      // оператор разыменования
		T* operator-(const size_t& it) { return el - it; }        // оператор разности между указателем и числом (арифм. указателей)
		T* operator+(const size_t& it) { return el + it; }        // оператор сложения между указателем и числом (арифм. указателей)
		T* operator++() { return ++el; }                          // префиксный инкримент
		T* operator++(int) { return el++; }                       // постфиксный инкримент
		T* operator--() { return --el; }                          // префиксный декримент
		T* operator--(int) { return el--; }                       // постфиксный декримент
		 
		bool operator>(const iterator& it) { return el > it.el; } // оператор сравнения указателей (больше)
		bool operator<(const iterator& it) { return el < it.el; } // оператор сравнения указателей (меньше)
		bool operator!=(const iterator& it) { return el != it.el; }
	};

	VecEno() : size(1), _capacity(2) { array = new T[_capacity]; }  // конструктор по умолчанию

	VecEno(const std::initializer_list<T>& _init)                   // конструктор с заданием uniform-инициализации
	: size(_init.size()), _capacity(degree(2, degree_two(size))) {
		array = size >= MAX_SIZE ? new T[MAX_SIZE] : new T[_capacity];
		uint32_t i = 0;
		for (auto it = _init.begin(), end = _init.end(); it != end; it++, i++)
			array[i] = *it;
	}
	VecEno(const VecEno<T>& vec)                                  // конструктор копирования
	: size(vec.size), _capacity(degree(2, degree_two(size))) { 
		array = new T[_capacity];
		for (size_t i = 0; i < size; i++)
			array[i] = vec[i];
	}
	~VecEno() { delete[] array; }                                 // деструктор

	const size_t getSize() const { return size; }                 // геттер для size
	const size_t getCapacity() const { return _capacity; }         // геттер для _capacity
	const size_t getMAX_SIZE() const { return MAX_SIZE; }         // геттер для MAX_SIZE
	iterator begin() const { return iterator(array); }            // геттер для begin
	iterator end() const { return iterator(array + size); }       // геттер для end

	void reverse() {
		for (size_t i = 0; i < size / 2; i++)
			swap((*this)[i], (*this)[size - 1 - i]);
	}

	void setCapacity(const size_t& _capacity) {                   // сеттер для _capacity
		T* temp_ptr = array;
		size_t tempCap = this->_capacity;
		this->_capacity = _capacity;
		array = new T[_capacity];
		for (size_t i = 0; i < tempCap; i++)
			array[i] = temp_ptr[i];
		delete[] temp_ptr;
	}

	void push_back(const T& el) {                                 // добавить элемент в конец
		if (size < _capacity) {
			array[size] = el;
			++size;
		}
		else {
			setCapacity(degree(2, degree_two(size)));
			push_back(el);
		}
	}
	void pop_back() { size--; }


	T& at(const size_t& ind) { return size > ind ? array[ind]     // обратится к элементу по индексу (безопасно)
		: throw "Выход за пределы вектора . . .\n"; } 
	T& operator[](const size_t& ind) { return array[ind]; }       // обратится к элементу по индексу

	friend std::ostream& operator<<                               // вывод вектора (для удобства)
		(std::ostream& os, const VecEno<T>& vec) {
		for (auto begin = vec.begin(), end = vec.end(); begin < end; begin++)
			std::cout << *begin << '\t';
		std::cout << std::endl;
		return os;
	}
};



double rad_deg(const double& rad) { return rad * RADIAN; }        // перевод радиан в грудусы
double deg_rad(const double& deg) { return deg * DEGREE; }        // перевод градусы в радианы

// reverse //
template<class T>                                                 // реверс массива встроенного типа
void reverse(T& arr) {
	for (size_t i = 0, size = sizeof(arr) / sizeof(arr[0]); i < size / 2; i++)
		swap(arr[i], arr[size - 1 - i]);
}

// SORT //
// choice sort //
template<typename T>
void sort(T& arr, bool smallset_to_largest = true) {              // сортировка массива встроенного типа
	for (size_t i = 0, g = 0, size = sizeof(arr) / sizeof(arr[0]); i != size - 1; i++)
		for (g = i + 1; g < size; g++)
			if (arr[i] != arr[g] && arr[i] > arr[g] == smallset_to_largest)
				swap(arr[i], arr[g]);
}

// min element //
template<typename T>
auto min_max(T& arr, bool _min = true) {                          // сортировка массива встроенного типа
	auto min_max = arr[0];
	for (size_t i = 1, size = sizeof(arr) / sizeof(arr[0]); i != size; i++)
		if (arr[i] != min_max && min_max > arr[i] == _min)
			min_max = arr[i];
	return min_max;
}
#endif
